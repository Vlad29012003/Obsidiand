
Explain analyze

Анализируем запрос. Стараемся исправить наш запрос или структуру данных таким образом что бы мы использовали оптимизированные структуры данных (индексы , правильные join)


Проблемма N+1
Возникает к контексте выполнения запросов к базе данных когда при получении связанных данных несколько раз выполняються дополнительные запросы к базе данных для каждой записи или обьекта полученного в первоначальном запросе.

Пример проблеммы N+1
Предположим у вас есть две таблицы: Authors (авторы) и Books(Книги) и вы хотите получить список авторов и их книг. Вы выполняете следующийй запрос 

SELECT *  FROM Authors;

Затем чтобы получить книги для каждого автора вы выполняете N дополнительных запросов (где Т - количество авторов) например:

SELECT *  FROM Books WHERE author_id = 1;
SELECT *  FROM Books WHERE author_id = 2;
SELECT *  FROM Books WHERE author_id = N;

Решение:
Использовать Joins
Использовать Под запросы
использовать оконные функции (Window functions)
Использование CTE (Common Table Expressions)

pg_stats_statement аналитика
Это модуль PostgreSQL который предоставляет информацию о выполненных SQL - запросах в базе данных. Он служит для мониторинга и анализа производительности запросов а так же для выявления узких мест и оптимизации SQL- Запроса




Django 
select_related и prefetch_related - это два метода оптимизации запросов в Django ORM которые позволяют уменьшить количество запросов к базе данных при получении связанных обьектов

select_related используеться для оптимизации запросов , когда у вас есть ForeignKey (или OneToOneField) на другую модель и вы хотите получить обьекты этой связанной модели вместе с обьектами из исходной модели. 

books = Book.objects.select_related('author')
одни запрос к базе данных

prefetch_related: используеться когда у вас есть обратное отношение через ForeignKey , ManyToManyField или Reverse Foreignkey и вы хотите получить связанные обьекты для каждого обьекта в исходной модели.
