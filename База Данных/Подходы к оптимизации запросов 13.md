
## `EXPLAIN ANALYZE`

Это команда СУБД (например, PostgreSQL или MySQL), которая **показывает, как именно база данных выполняет запрос**:  
какие индексы она использует, как соединяет таблицы, сколько строк реально обрабатывает и где “тормозит”.

Проблема **N+1** — это когда для выборки  выполняется **один основной запрос и N дополнительных** (по одному для каждой записи), вместо того чтобы получить всё нужное за **один объединённый запрос**.

**Пример проблемы N+1:**
У тебя есть таблица **authors** и таблица **books** (у каждой книги есть `author_id`).

```
SELECT * FROM authors;

```
и потом для каждого автора отдельно:
```
SELECT * FROM books WHERE author_id = 1;
SELECT * FROM books WHERE author_id = 2;
SELECT * FROM books WHERE author_id = 3;
```
Вместо того чтобы получить всё за один **JOIN-запрос**:
```
SELECT a.*, b.*
FROM authors a
LEFT JOIN books b ON a.id = b.author_id;

```


## `Решение`
### **1️⃣ Использовать JOINs**

**Суть:** объединяем таблицы через SQL JOIN, чтобы подтянуть связанные данные за один запрос.

### **2️⃣ Использовать подзапросы (Subqueries)**

**Суть:** выполнять вычисления через отдельный подзапрос, но возвращать результат как поле объекта.

### **3️⃣ Использовать оконные функции (Window functions)**

**Суть:** дают возможность вычислять агрегаты **с контекстом строки**, не сворачивая данные в одну строку.

### **4️⃣ Использование CTE (Common Table Expressions)**

**Суть:** создаём временный именованный результат (`WITH`), который можно использовать в основном запросе.


## **1️⃣ Что такое `pg_stat_statements`**

- Это **модуль расширения PostgreSQL**, который собирает статистику по всем выполняемым SQL-запросам.
- Позволяет видеть **частоту, время выполнения, блокировки и использование ресурсов** по каждому запросу.

## **Оптимизация на уровне Django`**

### **`select_related()`**

- Используется для **ForeignKey** и **OneToOneField**.
- Делает **JOIN на уровне SQL**, подтягивая связанные объекты за один запрос

### **`prefetch_related()`**

- Используется для **обратных связей и ManyToMany**.
- Django делает **2 запроса** и связывает объекты в памяти, предотвращая N+1.

## **2️⃣ Агрегации и вычисляемые поля**

### **`annotate()`**

- Добавляет вычисляемое поле к каждому объекту.
- Выполняется на уровне SQL, **не в Python**, экономя время.
### **`aggregate()`**

- Возвращает **сводные значения** для всего QuerySet.

## **3️⃣ Ограничение и оптимизация выборки**

- **`only()`** – выбирает только нужные поля, остальные не подтягиваются.
- **`defer()`** – откладывает выборку тяжёлых полей до их фактического использования.

```
tests = Test.objects.only('id', 'name')
```

## **4️⃣ Фильтры и условия**

- **`exists()`** – проверка наличия данных без вытаскивания всех строк.
- **`values()` / `values_list()`** – выбираем только нужные поля вместо объектов модели.

```
names = Test.objects.values_list('name', flat=True)

```